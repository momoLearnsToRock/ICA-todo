import baseRouter = require('./baseRouter');
import h = require('../helpers/misc');
import dbg = require('debug');
import express = require('express');
import http = require('http');

export class ActivitiesRouter extends baseRouter.BaseRouter {
  constructor({ table, disableGetAll, disablePost, disablePut, disablePatch, disableDelete }
    : { table: h.Helpers.SqlTableType, disableGetAll: boolean, disablePost: boolean, disablePut: boolean, disablePatch: boolean, disableDelete: boolean }) {
    super({ table: table, disableGetAll: disableGetAll, disablePost: disablePost, disablePut: disablePut, disablePatch: disablePatch, disableDelete: disableDelete });

    this.router.route('/:id/instantiateTodo')
      .get((req, res) => {
        res.send('try using the post verb');
      })
      .post((req, res) => {
        (async function query() {
          let result = null;
          try {
            if (req.itemById == null) {
              throw new Error('no data available');
            }
            result = await this.table.instantiateTodo(req.body, req.itemById);
            res.send(result);
          } catch (err) {
            let code: number = 500;
            switch (true) {
              case 'no data available' == err.message:
              case 'error' == err.message:
              case /^Body is missing the field/.test(err.message):
              case /^No fields could be parsed from body./.test(err.message):
              case /^The field '.*' entity.$/.test(err.message):
                code = 400;
                break;
            }
            res.status(code).send(err.message);
          }
        }.bind(this)());
      })


    this.router.route('/:activityId/tags')
      .get((req, res) => {
        (async function query() {
          try {
            let reqUrl = `$filter=activityId eq ${req.params.activityId}`;

            let rslt = await this.table.activitiesTagsTable.getAll(reqUrl);
            res.send(rslt);
          }
          catch (err) {
            console.log(err);
            let code: number = 500;
            switch (true) {
              case 'error' == err.message:
              case /^Parse error:/.test(err.message):
                code = 400;
                break;
            }
            res.status(code).send(err.message);
          }
        }.bind(this)());
      })
      .post((req, res) => {
        (async function query() {
          try {
            if (req.body.id) {
              if (this.table.activitiesTagsTable.autoGeneratedPrimaryKey) {
                throw new Error('id should not be passed, it will be generated by the system');
              }
            }
            req.body.activityId = req.params.activityId;
            let insResult = await this.table.activitiesTagsTable.insert(req.body, true);// the second parameter makes sure all the needed fields are passed
            res.status(201).send(insResult);
          } catch (err) {
            let code: number = 500;
            switch (true) {
              case 'an existing item already exists' == err.message:
                code = 409;
                break;
              case 'error' == err.message:
              case 'id should not be passed, it will be generated by the system' == err.message:
              case /^Body is missing the field/.test(err.message):
              case /^No fields could be parsed from body./.test(err.message):
              case /^The field '.*' entity.$/.test(err.message):
              case /^Could not find '.*' with the id: '.*'./.test(err.message):
              case /^An item with given identifier already exists.$/.test(err.message):
                code = 400;
                break;
            }
            res.status(code).send(err.message);
          }
        }.bind(this)());
      })

      this.router.use('/:activityId/tags/:tagId', (req, res, next) => {
        if (req.body.id && req.body.id !== req.params.id) {
          res.status(400).send('Wrong id was passed as part of the request body.');
        }
        else {
          (async function query() {
            try {
              let reqUrl = `$filter=(activityId eq ${req.params.activityId} and tagId eq ${req.params.tagId})`;

              let rslt = await this.table.activitiesTagsTable.getAll(reqUrl);
              if(!rslt || rslt.length==0){
                throw new Error(`Could not find an entry with the given id.`);
              }
              req.activityTagById = rslt[0];
              next();
            } catch (err) {
              let code: number = 500;
              switch (err.message) {
                case 'error':
                case 'Could not find an entry with the given id.':
                  code = 400;
                  break;
              }
              res.status(code).send(err.message);
            }
          }.bind(this)());
        }
      });
  
      this.router.route('/:activityId/tags/:tagId')
        .get((req, res) => {
          // if (req.itemById == null) {
          //   res.status(204).send({});
          // } else {
            res.send(req.activityTagById);
          // }      
        })
        .post((req, res) => {
          this.methodNotAvailable(res, `"post"`, `try using "post" on the address "activities/${req.params.activityId}/tags/:tagId" instead of "activities/${req.params.activityId}/tags/${req.params.tagId}"`);
        })
          .put((req, res) => {
          this.methodNotAvailable(res, "put","")
        })
        .patch((req, res) => {
          this.methodNotAvailable(res, "patch","")
        })
        .delete((req, res) => {
          (async function query() {
            try {
              if (req.activityTagById == null) {
                throw new Error('no data available');
              }
              await this.table.activitiesTagsTable.delete(req.activityTagById.id);
              res.status(204).send();
            } catch (err) {
              let code: number = 500;
              switch (err.message) {
                case 'no data available':
                case 'error':
                  code = 400;
                  break;
              }
              res.status(code).send(err.message);
            }
          }.bind(this)());
      
        })
  }
}