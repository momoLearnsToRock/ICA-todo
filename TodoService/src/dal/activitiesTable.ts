import sql = require('mssql');
import dbg =require('debug');
import h = require('../helpers/misc');
import odataV4Sql= require('odata-v4-sql');
import todosT = require('./todosTable');
import activtiesTagsT = require('./activitiesTagsTable');

const debug= dbg('todo:activitiesTable');

export class ActivitiesTable extends h.Helpers.SqlTableType {
  public activitiesTagsTable: h.Helpers.SqlTableType;
  public todosTable: todosT.TodosTable;
  constructor(connectionPool: sql.ConnectionPool){
    const activityFields: h.Helpers.SqlField[] = [
      new h.Helpers.SqlField({ name: 'id', type: sql.BigInt }),
      new h.Helpers.SqlField({ name: 'note', type: sql.NVarChar(sql.MAX) }),
      new h.Helpers.SqlField({ name: 'createdAt', type: sql.DateTime }),
      new h.Helpers.SqlField({ name: 'contentUrl', type: sql.NVarChar(512) }),
      new h.Helpers.SqlField({ name: 'title', type: sql.NVarChar(255) }),
      new h.Helpers.SqlField({ name: 'activityType', type: sql.NVarChar(50) }),
      new h.Helpers.SqlField({ name: 'priority', type: sql.Int }),
      new h.Helpers.SqlField({ name: 'categoryId', type: sql.BigInt }),
      // new h.Helpers.SqlField({name: 'categoryTitle', type: sql.NVarChar(100)}),
      new h.Helpers.SqlField({ name: 'modifiedOn', type: sql.DateTime }),
    ];

    super({ connectionPool: connectionPool, tableName: 'ActivitiesBase', viewName: 'Activities', fields: activityFields, autoGeneratedPrimaryKey: true, throwOnExtraFields: false });
    debug.enabled = true;

    this.activitiesTagsTable=new activtiesTagsT.ActivitiesTagsTable(connectionPool);
    this.todosTable=new todosT.TodosTable(connectionPool);
  }
    
  async getAll(q: string) {
    if(!q || q == '/' || q =='/?'){
      q='$top=100'
    }
    const query = odataV4Sql.createQuery(q);
    if(!query.limit){
      query.limit=1000;
    }
    if(query.limit>1000){
      throw new Error(`Parse error: max number of rows returned can be 1000. please adjust query to 'top=1000'`);
    }
    let result = null;
    try {
      const requ = new sql.Request(this.connectionPool);
      let sqlQuery = //`select ${query.select} from ${this.viewName}`;
  `
SELECT baseTable.id, baseTable.note, baseTable.createdAt, 
baseTable.contentUrl, baseTable.modifiedOn, baseTable.title, 
baseTable.activityType, baseTable.[priority], 
baseTable.categoryId AS [category.id], dbo.Categories.title AS [category.title], 
ISNULL((SELECT at.tagid AS [id], at.tagtitle AS [title]
      FROM ActivitiesTags AS at
      WHERE baseTable.id = at.activityId
      FOR JSON PATH), '[]') as tags
FROM dbo.ActivitiesBase AS baseTable
INNER JOIN dbo.Categories ON baseTable.categoryId = dbo.Categories.id

`
      let where = query.where;
      if (where) {
        for (let p of query.parameters) {
          if (where.indexOf('?') < 0) {
            throw new Error(`Parse error: could not parse near '${p[1]}'`);
          }
          requ.input(`${p[0]}`, `${p[1]}`);
          where = where.replace('?', `@${p[0]}`);
          where = where.replace('[', 'baseTable.[');
        }

        sqlQuery += `
WHERE ${where}`;
      }
      //TODO: Proper order by here
      sqlQuery += ` 
ORDER BY CURRENT_TIMESTAMP
OFFSET ${query.skip || 0} ROWS
FETCH NEXT ${query.limit} ROWS ONLY
FOR JSON PATH`;
      result = await requ.query(sqlQuery);
      result = result.recordset[0]["JSON_F52E2B61-18A1-11d1-B105-00805F49916B"];// the special name of the json column
      debug(result);
      return result;
    } catch (er) {
      debug(er);
      throw er;
    }
  }

  async getById(id: any) {
    let result = await this.getAll(`$filter=id eq ${id}`);
    debug('return of check for the same id', result);
    result = result != "" ? JSON.parse(result)[0] : null;
    return result;
  }

  async instantiateTodo(jsonBody: JSON, activity: any) {
    jsonBody = this.preParseJson(jsonBody);
    if (!jsonBody.assignedToId) throw new Error(`Body is missing the field 'assignedToId'`);
    if (!jsonBody.assignedToName) throw new Error(`Body is missing the field 'assignedToName'`);
    if (!jsonBody.assignedToObjectType) throw new Error(`Body is missing the field 'assignedToObjectType'`);

    activity.activityId = activity.id;
    delete activity.id;
    activity.todoType = activity.activityType;
    delete activity.activityType;
    activity.assignedToId = jsonBody.assignedToId;
    activity.assignedToName = jsonBody.assignedToName;
    activity.assignedToObjectType = jsonBody.assignedToObjectType;
    activity.dueAt = !jsonBody.dueAt ? null : jsonBody.dueAt;
    // activity.startsAt = !jsonBody.startsAt?null:jsonBody.startsAt;
    let todo = await this.todosTable.insert(activity, false);

    let activityTags = activity.tags;//JSON.parse(activity.tags);//await this.getTags(activity.activityId);
    // await activityTags.forEach(async function (at) {
    for(let i: number = 0; i < activityTags.length; i++){
      let at: any = activityTags[i];
      delete at.title;
      at.tagId = at.id;
      delete at.id;
      at.todoId = todo.id;
      const todostag = await this.todosTable.todosTagsTable.insert(at, false);
      debug(todostag);
    }// .bind(this));
    todo = await this.todosTable.getById(todo.id);
    return todo;
  }
  async customUpdateChecks(jsonBody: JSON){
    jsonBody = this.preParseJson(jsonBody);
  }
  async customInsertChecks(jsonBody: JSON){
    jsonBody = this.preParseJson(jsonBody);
    jsonBody.createdAt = new Date();
  }
  preParseJson(jsonBody: JSON): JSON {
    if (jsonBody.completedBy) {
      jsonBody.completedById = jsonBody.completedBy.id;
      jsonBody.completedByName = jsonBody.completedBy.name;
      delete jsonBody.completedBy;
    }
    if (jsonBody.assignedTo) {
      jsonBody.assignedToId = jsonBody.assignedTo.id;
      jsonBody.assignedToName = jsonBody.assignedTo.name;
      jsonBody.assignedToObjectType = jsonBody.assignedTo.objectType;
      delete jsonBody.assignedTo;
    }
    if (jsonBody.category) {
      jsonBody.categoryId = jsonBody.category.id;
      delete jsonBody.category;
    }
    return jsonBody;
  }
}
