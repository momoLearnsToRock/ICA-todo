import sql = require('mssql');
import dbg = require('debug');
import odataV4Sql = require('odata-v4-sql');

const debug = dbg('todo:helpers');
export module Helpers {
  export class ResponseDTO {
    public message: string;
    public data: any;
    constructor({ message, data }: { message: string, data: any }) {
      this.message = message;
      this.data = data;
    }
  }
  export class SqlField {
    public name: string;
    public type: sql.ISqlTypeFactory;
    constructor({ name, type }: { name: string, type: sql.ISqlTypeFactory }) {
      this.name = name;
      this.type = type;
    }
  }

  export class TableType {
    public tableName: string; // the table name used for update, delete and post
    public viewName: string; // the view name used for selects (in many cases view name and table name are the same)
    public throwOnExtraFields: boolean;  //TODO: maybe this is not needed anymore now that we have viewName and tableName
    constructor(tableName: string, viewName: string, throwOnExtraFields: boolean) {
      this.tableName = tableName;
      this.viewName = viewName;
      this.throwOnExtraFields = throwOnExtraFields;
    }
  }
  export class SqlTableType extends TableType {
    public fields: SqlField[];
    // public tableName: string;
    public autoGeneratedPrimaryKey: boolean;
    public connectionPool: sql.ConnectionPool;
    constructor({ connectionPool, tableName, viewName, fields, autoGeneratedPrimaryKey, throwOnExtraFields }: { connectionPool: sql.ConnectionPool, tableName: string, viewName: string, fields: SqlField[], autoGeneratedPrimaryKey: boolean, throwOnExtraFields: boolean }) {
      super(tableName, viewName, throwOnExtraFields);
      // this.tableName = tableName;
      this.fields = fields;
      this.autoGeneratedPrimaryKey = autoGeneratedPrimaryKey;
      this.connectionPool = connectionPool;
    }
    public getFieldNames(includeId: boolean): string {
      let fieldsString = '';
      this.fields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          fieldsString += item.name;
          if (index !== this.fields.length - 1) {
            fieldsString += ', ';
          }
        }
      });
      return fieldsString;
    }

    parseFieldsInJsonBody({ includeId, jsonBody, throwOnMissingFields, throwOnMissingModifiedOn, throwOnExtraFields, sqlReq, queryFields }:
      { includeId: boolean, jsonBody: JSON, throwOnMissingFields: boolean, throwOnMissingModifiedOn: boolean, throwOnExtraFields: boolean, sqlReq: sql.Request, queryFields: Helpers.SqlField[] }): string[] {
      const parsedFieldsList: string[] = [];
      queryFields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          if (item.name === 'modifiedOn') {
            if (throwOnMissingModifiedOn && typeof jsonBody[item.name] == 'undefined') {
              throw new Error(`Body is missing the field '${item.name}'.`);
            }
          } else {
            if (throwOnMissingFields && typeof jsonBody[item.name] == 'undefined') {
              throw new Error(`Body is missing the field '${item.name}'.`);
            }
            if(!jsonBody[item.name]){
              return;
            }
            sqlReq.input(item.name, item.type as sql.ISqlType, item.type == sql.DateTime ? new Date(jsonBody[item.name]) : jsonBody[item.name]);
          }
          parsedFieldsList.push(item.name);
        }
      });
      if (parsedFieldsList.length == 0) {
        throw new Error('No fields could be parsed from body.');
      }
      if (throwOnExtraFields) {
        let bodyKeys: string[] = Object.keys(jsonBody);
        bodyKeys.forEach((item, index) => {
          if (queryFields.map((f: SqlField) => { return f.name }).indexOf(item) < 0) {
            throw new Error(`The field '${item}' does not exist on the '${this.tableName}' entity. Try removing it from the body.`);
          }
        });
      }
      return parsedFieldsList;
    }


    createInsertIntoStatement(includeId: boolean, jsonBody: JSON, sqlReq: sql.Request, throwOnMissingFields: boolean) {
      const parsedFieldsList: string[] = this.parseFieldsInJsonBody({
        includeId: includeId,
        jsonBody: jsonBody,
        throwOnMissingFields: throwOnMissingFields,
        throwOnMissingModifiedOn: false,
        throwOnExtraFields: this.throwOnExtraFields,
        sqlReq: sqlReq,
        queryFields: this.fields
      });

      const indexOfId: number = this.fields.map((f) => { return f.name; }).indexOf('id');
      const PKType: sql.ISqlTypeFactory = this.fields[indexOfId].type;

      const query =
        `DECLARE @_keys table([id] ${PKType.declaration})
  
       INSERT INTO ${this.tableName} (${parsedFieldsList.map((f) => { return `[${f}]`; }).join(', ')}) 
       OUTPUT inserted.id INTO @_keys
       VALUES (${parsedFieldsList.map((f) => { return f == 'modifiedOn' ? 'GETDATE()' : `@${f}` }).join(', ')})
  
       SELECT t.*
       FROM @_keys AS g 
       JOIN dbo.${this.viewName} AS t 
       ON g.id = t.id`;
      // this method is a copy of what EF does
      return query;
    }

    createDeleteStatement(id: any, sqlReq: sql.Request) {
      sqlReq.input('id', id);
      return `DELETE FROM ${this.tableName} WHERE id = @id`;
    }

    async getAll(q: string) {
      if (!q || q == '/' || q == '/?') {
        q = '$top=100'
      }
      const query = odataV4Sql.createQuery(q);
      if (!query.limit) {
        query.limit = 1000;
      }
      if (query.limit > 1000) {
        throw new Error(`Parse error: max number of rows returned can be 1000. please adjust query to 'top=1000'`);
      }
      let result = null;
      try {
        const requ = new sql.Request(this.connectionPool);
        let sqlQuery = `select ${query.select} from ${this.viewName}`;
        let where = query.where;
        if (where) {
          for (let p of query.parameters) {
            if (where.indexOf('?') < 0) {
              throw new Error(`Parse error: could not parse near '${p[1]}'`);
            }
            requ.input(`${p[0]}`, `${p[1]}`);
            where = where.replace('?', `@${p[0]}`);
          }

          sqlQuery += ` WHERE ${where}`;
        }
        //TODO: Proper order by here
        sqlQuery += ` 
        ORDER BY CURRENT_TIMESTAMP`;
        sqlQuery += ` 
        OFFSET ${query.skip || 0} ROWS`;
        sqlQuery += ` 
        FETCH NEXT ${query.limit} ROWS ONLY`;
        result = await requ.query(sqlQuery);
        debug(result.toString());
        return result.recordset;
      } catch (er) {
        debug(er);
        throw er;
      }
    }

    createUpdateStatement(includeId: boolean, jsonBody: JSON, id: any, sqlReq: sql.Request, throwOnMissingFields: boolean) {
      const parsedFieldsList: string[] = this.parseFieldsInJsonBody({
        includeId: includeId,
        jsonBody: jsonBody,
        throwOnMissingFields: throwOnMissingFields,
        throwOnMissingModifiedOn: false,
        throwOnExtraFields: true,
        sqlReq: sqlReq,
        queryFields: this.fields
      });

      sqlReq.input('id', id);
      const query =
        `UPDATE ${this.tableName}
        SET ${parsedFieldsList.map((f) => {
          let str: string = `[${f}]= `;
          str += f != 'modifiedOn' ? `@${f}` : 'GETDATE()';
          return str;
        }).join(', ')} 
        WHERE id = @id
        SELECT * from ${this.viewName}
        WHERE id = @id
        `;
      debug(query);
      return query;
    }

    async insert(jsonBody: JSON, throwOnMissingFields: boolean) {
      this.customInsertChecks(jsonBody);
      let result = null;
      let msg = '';
      try {
        // note that the check for existing id must already be done.
        const requestIns = new sql.Request(this.connectionPool);
        result = await requestIns.query(this.createInsertIntoStatement(!this.autoGeneratedPrimaryKey, jsonBody, requestIns, throwOnMissingFields));
        if (result.rowsAffected[0] != 0) {
          msg = 'item created';
        }
        debug('return of insert', result);
        return result.recordset[0];
      } catch (err) {
        debug(err);
        throw err;
      }
    }

    async getById(id: any) {
      const requ = new sql.Request(this.connectionPool);
      debug('select by id: ', `select * from ${this.viewName} where id= @id`);
      requ.input('id', id);
      let result = await requ.query(`select * from ${this.viewName} where id= @id`);
      debug('return of check for the same id', result);
      let item = null;
      if (!!result.recordset && result.recordset.length === 1) {
        item = result.recordset[0];
      }
      return item;
    }

    async delete(id: any) {
      let result = null;
      const requ = new sql.Request(this.connectionPool);
      result = await requ.query(this.createDeleteStatement(id, requ));
      debug('return of check for the delete statement', result);
      return true;
    }

    async update(jsonBody: JSON, id: any, throwOnMissingFields: boolean) {
      this.customUpdateChecks(jsonBody);
      let result = null;
      let requ = new sql.Request(this.connectionPool);
      debug('update query');
      result = await requ.query(this.createUpdateStatement(!this.autoGeneratedPrimaryKey, jsonBody, id, requ, throwOnMissingFields));
      debug('result of update ', result);
      if (typeof result.recordset[0] == 'undefined') {
        throw new Error('server error');
      }
      return result.recordset[0];
    }

    customUpdateChecks(jsonBody: JSON){
      //custom checks here. can be overriden in children. if you find an error throw!
      return;
    }

    customInsertChecks(jsonBody: JSON){
      //custom checks here. can be overriden in children. if you find an error throw!
      return;
    }
  }
}