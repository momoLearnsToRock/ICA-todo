import sql = require('mssql');
import dbg =require('debug');
import odataV4Sql = require('odata-v4-sql');

const debug = dbg('todo:helpers');
export module Helpers{
  export class ResponseDTO {
    public message: string;
    public data: any;
    constructor({message, data}: {message: string, data: any}){
      this.message= message;
      this.data= data;
    }
  }
  export class SqlField {
    public name: string;
    public type: sql.ISqlTypeFactory;
    constructor({name, type}: {name: string, type: sql.ISqlTypeFactory}) {
      this.name = name;
      this.type = type;
    }
  }

  export class TableType{
    public tableName: string; // the table name used for update, delete and post
    public viewName: string; // the view name used for selects (in many cases view name and table name are the same)
    public throwOnExtraFields: boolean;  //TODO: maybe this is not needed anymore now that we have viewName and tableName
    constructor(tableName: string, viewName: string, throwOnExtraFields: boolean){
      this.tableName= tableName;
      this.viewName= viewName;
      this.throwOnExtraFields= throwOnExtraFields;
    }
  }
  export class SqlTableType extends TableType{
    public fields : SqlField[];
    // public tableName: string;
    public autoGeneratedPrimaryKey: boolean;
    public connectionPool: sql.ConnectionPool;
    constructor({connectionPool, tableName, viewName, fields, autoGeneratedPrimaryKey, throwOnExtraFields}: {connectionPool:sql.ConnectionPool, tableName: string, viewName: string, fields: SqlField[], autoGeneratedPrimaryKey: boolean, throwOnExtraFields: boolean}) {
      super(tableName, viewName, throwOnExtraFields);
      // this.tableName = tableName;
      this.fields = fields;
      this.autoGeneratedPrimaryKey = autoGeneratedPrimaryKey;
      this.connectionPool = connectionPool;
    }
    public getFieldNames(includeId: boolean): string{
      let fieldsString = '';
      this.fields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          fieldsString += item.name;
          if (index !== this.fields.length - 1) {
            fieldsString += ', ';
          }
        }
      });
      return fieldsString;
    }

    parseFieldsInJsonBody({includeId, jsonBody, throwOnMissingFields, throwOnMissingModifiedOn, throwOnExtraFields, sqlReq}: 
      {includeId: boolean, jsonBody: JSON, throwOnMissingFields: boolean, throwOnMissingModifiedOn: boolean, throwOnExtraFields: boolean, sqlReq: sql.Request}) :string[]{
      const parsedFieldsList: string[]= [];
      this.fields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          if (item.name === 'modifiedOn') {
            if( throwOnMissingModifiedOn && typeof jsonBody[item.name] == 'undefined'){
              throw new Error(`Body is missing the field '${item.name}'.`);
            }
          } else {
            if( throwOnMissingFields && typeof jsonBody[item.name] == 'undefined'){
              throw new Error(`Body is missing the field '${item.name}'.`);
            }
            sqlReq.input(item.name, item.type as sql.ISqlType, item.type==sql.DateTime?new Date(jsonBody[item.name]): jsonBody[item.name];
          }
          parsedFieldsList.push(item.name);
        }
      });
      if(parsedFieldsList.length==0){
        throw new Error('No fields could be parsed from body.');
      }
      if (throwOnExtraFields) {
        let bodyKeys: string[] = Object.keys(jsonBody);
        bodyKeys.forEach((item, index) => {
          if (this.fields.map((f: SqlField) => { return f.name }).indexOf(item) < 0) {
            throw new Error(`The field '${item}' does not exist on the '${this.tableName}' entity. Try removing it from the body.`);
          }
        });
      }
      return parsedFieldsList;
    }

    createInsertIntoStatement(includeId: boolean, jsonBody: JSON, sqlReq: sql.Request) {
      const parsedFieldsList: string[] = this.parseFieldsInJsonBody({includeId: includeId, jsonBody: jsonBody, throwOnMissingFields: true, throwOnMissingModifiedOn: false, throwOnExtraFields: this.throwOnExtraFields, sqlReq: sqlReq});

      const indexOfId: number = this.fields.map((f) => { return f.name; }).indexOf('id');
      const PKType: sql.ISqlTypeFactory = this.fields[indexOfId].type;

      const query =
        `DECLARE @_keys table([Id] ${PKType.declaration})
  
       INSERT INTO ${this.tableName} (${parsedFieldsList.map((f) => { return `[${f}]`; }).join(', ')}) 
       OUTPUT inserted.Id INTO @_keys
       VALUES (${parsedFieldsList.map((f) => { return f == 'modifiedOn' ? 'GETDATE()' : `@${f}` }).join(', ')})
  
       SELECT t.*
       FROM @_keys AS g 
       JOIN dbo.${this.viewName} AS t 
       ON g.Id = t.Id`;
      // this method is a copy of what EF does
      return query;
    }

    createDeleteStatement(id: any, sqlReq: sql.Request) {
      sqlReq.input('id', id);
      return `DELETE FROM ${this.tableName} WHERE Id = @id`; 
    }

    async getAll(q: string) {
      if(!q || q == '/' || q =='/?'){
        q='$top=100'
      }
      const query = odataV4Sql.createQuery(q);
      if(!query.limit){
        query.limit=1000;
      }
      if(query.limit>1000){
        throw new Error(`Parse error: max number of rows returned can be 1000. please adjust query to 'top=1000'`);
      }
      let result = null;
      try {
        const requ = new sql.Request(this.connectionPool);
        result = await requ.query(`select * from ${this.viewName}`);
        debug(result.toString());
        return result;
      } catch (er) {
        debug(er);
        throw er;
      }
    }

    createUpdateStatement(includeId: boolean, jsonBody: JSON, id: any, sqlReq: sql.Request) {
      const parsedFieldsList: string[] = this.parseFieldsInJsonBody({includeId: includeId, jsonBody: jsonBody, throwOnMissingFields: true, throwOnMissingModifiedOn: false, throwOnExtraFields: true, sqlReq: sqlReq});

      sqlReq.input('id', id);
      const query =
        `UPDATE ${this.tableName}
        SET ${parsedFieldsList.map((f)=>{let str: string= `[${f}]= `;
        str +=f!='modifiedOn'?`@${f}`:'GETDATE()';
        return str;
      }).join(', ')} 
        WHERE Id = @id
        SELECT * from ${this.viewName}
        WHERE Id = @id
        `;
      debug(query);
      return query;
    }

    async insert(jsonBody: JSON) {
      let result = null;
      let msg = '';
      try {
        // note that the check for existing id must already be done.
        const requestIns = new sql.Request(this.connectionPool);
        result = await requestIns.query(this.createInsertIntoStatement(!this.autoGeneratedPrimaryKey, jsonBody, requestIns));
        if (result.rowsAffected[0] != 0) {
          msg = 'item created';
        }
        debug('return of insert', result);
        return result;
      } catch (err) {
        debug(err);
        throw err;
      }
    }

    async getById(id: any) {
      const requ = new sql.Request(this.connectionPool);
      debug('select by id: ', `select * from ${this.viewName} where Id= @id`);
      requ.input('id', id);
      let result = await requ.query(`select * from ${this.viewName} where Id= @id`)
      debug('return of check for the same id', result);
      let item = null;
      if (!!result.recordset && result.recordset.length === 1) {
        item = result.recordset[0];
      }
      return item;
    }

    async delete(id: any) {
      let result = null;
      const requ = new sql.Request(this.connectionPool);
      result = await requ.query(this.createDeleteStatement(id, requ));
      debug('return of check for the delete statement', result);
      return true;
    }

    async update(jsonBody: JSON, id: any) {
      let result = null;
      let requ = new sql.Request(this.connectionPool);
      debug('update query');
      result = await requ.query(this.createUpdateStatement(!this.autoGeneratedPrimaryKey, jsonBody, id, requ));
      debug('result of update ', result);
      if(typeof result.recordset[0] == 'undefined'){
        throw new Error('server error');
      }
      return result.recordset[0];
    }    
  }
}