import sql = require('mssql');
import dbg =require('debug');
const debug = dbg('todo:helpers');



export module Helpers{
  export class ResponseDTO {
    public message: string;
    public data: any;
    constructor({message, data}: {message: string, data: any}){
      this.message= message;
      this.data= data;
    }
  }
  export class SqlField {
    public name: string;
    public type: string;
    constructor({name, type}: {name: string, type: string}) {
      this.name = name;
      this.type = type;
    }
  }
  export class TableType{
    public tableName: string;
    constructor(name: string){
      this.tableName= name;
    }
  }
  export class SqlTableType extends TableType{
    public fields : SqlField[];
    // public tableName: string;
    public autoGeneratedPrimaryKey: boolean;
    public connectionPool: sql.ConnectionPool;
    constructor({connectionPool, tableName, fields, autoGeneratedPrimaryKey}: {connectionPool:sql.ConnectionPool, tableName: string, fields: SqlField[], autoGeneratedPrimaryKey: boolean}) {
      super(tableName);
      // this.tableName = tableName;
      this.fields = fields;
      this.autoGeneratedPrimaryKey = autoGeneratedPrimaryKey;
      this.connectionPool = connectionPool;
    }
    public getFieldNames(includeId: boolean): string{
      let fieldsString = '';
      this.fields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          fieldsString += item.name;
          if (index !== this.fields.length - 1) {
            fieldsString += ', ';
          }
        }
      });
      return fieldsString;
    }

    createInsertIntoStatement(includeId: boolean, jsonBody: JSON, sqlReq: sql.Request) {
      const fields = this.getFieldNames(includeId);
      const values: string[] = [];
      this.fields.forEach((item, index) => {
        if (includeId || item.name.toLowerCase() !== 'id') {
          if (item.name === 'ModifiedOn') {
            values.push('GETDATE()');
          } else {
            values.push(`@${item.name}`);
            sqlReq.input(`${item.name}`, jsonBody[item.name]);
          }
        }
      });
      const PKType = 'nvarchar(MAX)';// 'bigint'; // the sql datatype of the table's PK. Todo: get this value on instantiation of the tables in future
      const query =
        `DECLARE @_keys table([Id] ${PKType})
  
       INSERT INTO ${this.tableName} (${fields}) 
       OUTPUT inserted.Id INTO @_keys
       VALUES (${values.join(', ')})
  
       SELECT t.*
       FROM @_keys AS g 
       JOIN dbo.${this.tableName} AS t 
       ON g.Id = t.Id`;
      // note to developers: SCOPE_IDENTITY() would have been a good option but we have nvarchar ids. this method is a copy of what EF does
      return query;
    }

    createDeleteStatement(id: any, sqlReq: sql.Request) {
      sqlReq.input('id', id);
      return `DELETE FROM ${this.tableName} WHERE Id = @id`; 
    }

    async getAll() {
      let result = null;
      try {
        const requ = new sql.Request(this.connectionPool);
        result = await requ.query(`select * from ${this.tableName}`);
        debug(result.toString());
        return (new ResponseDTO({message: '', data: result}));
      } catch (er) {
        debug(er);
        return (new ResponseDTO({message: 'error', data: result}));
      }
    }

    async insert(jsonBody: JSON) {
      let result = null;
      let msg = '';
      try {
        // note that the check for existing id must already be done.
        const requestIns = new sql.Request(this.connectionPool);
        result = await requestIns.query(this.createInsertIntoStatement(!this.autoGeneratedPrimaryKey, jsonBody, requestIns));
        if (result.rowsAffected[0] != 0) {
          msg = 'item created';
        }
        debug('return of insert', result);
        return new ResponseDTO({message:msg, data:result});
      } catch (err) {
        debug(err);
        return new ResponseDTO({message:'error', data:result});
      }
    }

    async getById(id: any) {
      const requ = new sql.Request(this.connectionPool);
      debug('select by id: ', `select * from ${this.tableName} where Id= @id`);
      requ.input('id', id);
      let result = await requ.query(`select * from ${this.tableName} where Id= @id`)
      debug('return of check for the same id', result);
      let item = null;
      if (!!result.recordset && result.recordset.length === 1) {
        item = result.recordset[0];
      }
      return new ResponseDTO({ message: '', data: item });
    }

    async delete(id: any) {
      let result = null;
      const requ = new sql.Request(this.connectionPool);
      result = await requ.query(this.createDeleteStatement(id, requ));
      debug('return of check for the delete statement', result);
      return true;
    }

    
  }
}

