"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sql = require("mssql");
const dbg = require("debug");
const h = require("../helpers/misc");
const sqlTableType_1 = require("./sqlTableType");
const todoCardsTable_1 = require("./todoCardsTable");
const debug = dbg('todo:todosTable');
class TodosTable extends sqlTableType_1.SqlTableType {
    constructor(connectionPool) {
        const todoFields = [
            new h.Helpers.SqlField({ name: 'id', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'note', type: sql.NVarChar(sql.MAX) }),
            new h.Helpers.SqlField({ name: 'createdAt', type: sql.DateTime }),
            new h.Helpers.SqlField({ name: 'contentUrl', type: sql.NVarChar(512) }),
            new h.Helpers.SqlField({ name: 'title', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'todoType', type: sql.NVarChar(50) }),
            new h.Helpers.SqlField({ name: 'priority', type: sql.Int }),
            new h.Helpers.SqlField({ name: 'categoryId', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'completedAt', type: sql.DateTime }),
            new h.Helpers.SqlField({ name: 'completedById', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'completedByName', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'isCompleted', type: sql.Bit }),
            new h.Helpers.SqlField({ name: 'assignedToId', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'assignedToName', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'assignedToObjectType', type: sql.NVarChar(50) }),
            new h.Helpers.SqlField({ name: 'dueAt', type: sql.DateTime }),
            new h.Helpers.SqlField({ name: 'activityId', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'modifiedOn', type: sql.DateTime }),
            new h.Helpers.SqlField({ name: 'createdById', type: sql.NVarChar(255) }),
            new h.Helpers.SqlField({ name: 'createdByName', type: sql.NVarChar(255) })
        ];
        super({ connectionPool: connectionPool, tableName: 'TodosBase', viewName: 'TodosSimple', fields: todoFields, autoGeneratedPrimaryKey: true, throwOnExtraFields: false });
        debug.enabled = true;
        const todoTagFields = [
            new h.Helpers.SqlField({ name: 'id', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'todoId', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'tagId', type: sql.BigInt }),
            new h.Helpers.SqlField({ name: 'modifiedOn', type: sql.DateTime }),
        ];
        this.todosTagsTable = new sqlTableType_1.SqlTableType({ connectionPool: connectionPool, tableName: 'TodosTagsBase', viewName: 'TodosTags', fields: todoTagFields, autoGeneratedPrimaryKey: true, throwOnExtraFields: true });
        this.todoCardsTable = new todoCardsTable_1.TodoCardsTable(connectionPool);
    }
    async customUpdateChecks(jsonBody) {
        jsonBody = TodosTable.preParseJson(jsonBody);
        if ((jsonBody.completedAt || jsonBody.completedById || jsonBody.completedByName) && (!jsonBody.completedAt || !jsonBody.completedById || !jsonBody.completedByName)) { //all or none
            throw new Error(`Body is missing the fields för closing todo. all the fields 'completedAt' and 'completedById' and 'completedByName' must be present.`);
        }
        if ((jsonBody.assignedToId || jsonBody.assignedToName || jsonBody.assignedToObjectType) && (!jsonBody.assignedToId || !jsonBody.assignedToName || !jsonBody.assignedToObjectType)) { //all or none
            throw new Error(`Body is missing the fields för assigning todo. all the fields 'assignedToId' and 'assignedToName' and 'assignedToObjectType' must be present.`);
        }
        return;
    }
    async customInsertChecks(jsonBody) {
        await this.customUpdateChecks(jsonBody);
        jsonBody.createdAt = new Date();
    }
    static preParseJson(jsonBody) {
        if (jsonBody.completedBy) {
            jsonBody.completedById = jsonBody.completedBy.id;
            jsonBody.completedByName = jsonBody.completedBy.name;
            delete jsonBody.completedBy;
        }
        if (jsonBody.assignedTo) {
            jsonBody.assignedToId = jsonBody.assignedTo.id;
            jsonBody.assignedToName = jsonBody.assignedTo.name;
            jsonBody.assignedToObjectType = jsonBody.assignedTo.objectType;
            delete jsonBody.assignedTo;
        }
        if (jsonBody.category) {
            jsonBody.categoryId = jsonBody.category.id;
            delete jsonBody.category;
        }
        return jsonBody;
    }
    async updateTodoAndCards(jsonBody, id, throwOnMissingFields, previousStateTodo) {
        const transaction = new sql.Transaction(this.connectionPool);
        if (jsonBody.tags) {
            delete jsonBody.tags;
        }
        const todoCards = jsonBody.cards;
        const previousStateTodoCards = await this.todoCardsTable.getAll(`$filter=todoId eq ${id}`);
        if (jsonBody.completedAt) { // ska stängas
            for (let i = 0; i < previousStateTodoCards.length; i++) { // är ala kort stängd?
                const pstc = previousStateTodoCards[i];
                const jsonBodytc = todoCards.find((jbtc) => { return jbtc.id == pstc.id; });
                let isCardClosed = false;
                isCardClosed = (jsonBodytc && jsonBodytc.hasOwnProperty('outputText')) ? !!jsonBodytc.outputText : !!pstc.outputText;
                isCardClosed = (isCardClosed || !!pstc.outputFileData);
                if (!isCardClosed) {
                    throw new Error(`TodoService error. A todo can not be closed before all cards are closed. card with id ${pstc.id} needs to be clsoed.`);
                }
            }
        }
        await transaction.begin();
        try {
            if (jsonBody.cards && jsonBody.cards.length > 0) {
                for (let i = 0; i < todoCards.length; i++) {
                    let tc = todoCards[i];
                    const previousTodoCardState = previousStateTodo.cards.find((card) => { return card.id == tc.id; });
                    if (!previousTodoCardState) { // är id på todokort gilltig?
                        throw new Error(`TodoService error. Card with id ${tc.id} does not belong to todo ${id}.`);
                    }
                    if (tc.todoId && tc.todoId != id) { // är todoId på todokort gilltig?
                        throw new Error(`TodoService error. Card with id ${tc.id} does not belong to todo ${id}.`);
                    }
                    const tcUpdateResult = await this.todoCardsTable.updateTransPool(tc, tc.id, false, transaction);
                    debug(tcUpdateResult);
                } // .bind(this));
                delete jsonBody.cards;
            }
            const result = await this.updateTransPool(jsonBody, id, throwOnMissingFields, transaction);
            await transaction.commit();
            return result;
        }
        catch (ex) {
            await transaction.rollback();
            throw ex;
        }
    }
}
exports.TodosTable = TodosTable;
//# sourceMappingURL=todosTable.js.map